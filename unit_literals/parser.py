#!/usr/bin/env python3.8
# @generated by pegen from unit_literals/grammar.txt

import ast
import sys
import tokenize

from typing import Any, Optional

from .pegen_parser import memoize, memoize_left_rec, logger, Parser

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):
    @memoize
    def start(self) -> Optional[Any]:
        # start: file
        mark = self._mark()
        while True:
            _last = self.file()
            file = _last
            if not _last:
                break
            return file
        self._reset(mark)
        return None

    @memoize
    def file(self) -> Optional[Any]:
        # file: statements? $
        mark = self._mark()
        while True:
            _last = (self.statements(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("ENDMARKER")
            _endmarker = _last
            if not _last:
                break
            return [opt, _endmarker]
        self._reset(mark)
        return None

    @memoize
    def interactive(self) -> Optional[Any]:
        # interactive: statement_newline
        mark = self._mark()
        while True:
            _last = self.statement_newline()
            statement_newline = _last
            if not _last:
                break
            return statement_newline
        self._reset(mark)
        return None

    @memoize
    def eval(self) -> Optional[Any]:
        # eval: expressions NEWLINE* $
        mark = self._mark()
        while True:
            _last = self.expressions()
            expressions = _last
            if not _last:
                break
            _last = (self._loop0_1(),)
            _loop0_1 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("ENDMARKER")
            _endmarker = _last
            if not _last:
                break
            return [expressions, _loop0_1, _endmarker]
        self._reset(mark)
        return None

    @memoize
    def func_type(self) -> Optional[Any]:
        # func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self.type_expressions(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            _last = self.expect("->")
            literal_2 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = (self._loop0_2(),)
            _loop0_2 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("ENDMARKER")
            _endmarker = _last
            if not _last:
                break
            return [
                literal,
                opt,
                literal_1,
                literal_2,
                expression,
                _loop0_2,
                _endmarker,
            ]
        self._reset(mark)
        return None

    @memoize
    def fstring(self) -> Optional[Any]:
        # fstring: star_expressions
        mark = self._mark()
        while True:
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            return star_expressions
        self._reset(mark)
        return None

    @memoize
    def type_expressions(self) -> Optional[Any]:
        # type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        mark = self._mark()
        while True:
            _last = self._gather_3()
            _gather_3 = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expect("*")
            literal_1 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_2 = _last
            if not _last:
                break
            _last = self.expect("**")
            literal_3 = _last
            if not _last:
                break
            _last = self.expression()
            expression_1 = _last
            if not _last:
                break
            return [
                _gather_3,
                literal,
                literal_1,
                expression,
                literal_2,
                literal_3,
                expression_1,
            ]
        self._reset(mark)
        while True:
            _last = self._gather_5()
            _gather_5 = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expect("*")
            literal_1 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [_gather_5, literal, literal_1, expression]
        self._reset(mark)
        while True:
            _last = self._gather_7()
            _gather_7 = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expect("**")
            literal_1 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [_gather_7, literal, literal_1, expression]
        self._reset(mark)
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            _last = self.expect("**")
            literal_2 = _last
            if not _last:
                break
            _last = self.expression()
            expression_1 = _last
            if not _last:
                break
            return [literal, expression, literal_1, literal_2, expression_1]
        self._reset(mark)
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        while True:
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        while True:
            _last = self._gather_9()
            _gather_9 = _last
            if not _last:
                break
            return _gather_9
        self._reset(mark)
        return None

    @memoize
    def statements(self) -> Optional[Any]:
        # statements: statement+
        mark = self._mark()
        while True:
            _last = self._loop1_11()
            _loop1_11 = _last
            if not _last:
                break
            return _loop1_11
        self._reset(mark)
        return None

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: compound_stmt | simple_stmt
        mark = self._mark()
        while True:
            _last = self.compound_stmt()
            compound_stmt = _last
            if not _last:
                break
            return compound_stmt
        self._reset(mark)
        while True:
            _last = self.simple_stmt()
            simple_stmt = _last
            if not _last:
                break
            return simple_stmt
        self._reset(mark)
        return None

    @memoize
    def statement_newline(self) -> Optional[Any]:
        # statement_newline: compound_stmt NEWLINE | simple_stmt | NEWLINE | $
        mark = self._mark()
        while True:
            _last = self.compound_stmt()
            compound_stmt = _last
            if not _last:
                break
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            return [compound_stmt, _newline]
        self._reset(mark)
        while True:
            _last = self.simple_stmt()
            simple_stmt = _last
            if not _last:
                break
            return simple_stmt
        self._reset(mark)
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            return _newline
        self._reset(mark)
        while True:
            _last = self.expect("ENDMARKER")
            _endmarker = _last
            if not _last:
                break
            return _endmarker
        self._reset(mark)
        return None

    @memoize
    def simple_stmt(self) -> Optional[Any]:
        # simple_stmt: small_stmt !';' NEWLINE | ';'.small_stmt+ ';'? NEWLINE
        mark = self._mark()
        while True:
            _last = self.small_stmt()
            small_stmt = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, ";")
            if not _last:
                break
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            return [small_stmt, _newline]
        self._reset(mark)
        while True:
            _last = self._gather_12()
            _gather_12 = _last
            if not _last:
                break
            _last = (self.expect(";"),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            return [_gather_12, opt, _newline]
        self._reset(mark)
        return None

    @memoize
    def small_stmt(self) -> Optional[Any]:
        # small_stmt: assignment | star_expressions | return_stmt | import_stmt | raise_stmt | 'pass' | del_stmt | yield_stmt | assert_stmt | 'break' | 'continue' | global_stmt | nonlocal_stmt
        mark = self._mark()
        while True:
            _last = self.assignment()
            assignment = _last
            if not _last:
                break
            return assignment
        self._reset(mark)
        while True:
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            return star_expressions
        self._reset(mark)
        while True:
            _last = self.return_stmt()
            return_stmt = _last
            if not _last:
                break
            return return_stmt
        self._reset(mark)
        while True:
            _last = self.import_stmt()
            import_stmt = _last
            if not _last:
                break
            return import_stmt
        self._reset(mark)
        while True:
            _last = self.raise_stmt()
            raise_stmt = _last
            if not _last:
                break
            return raise_stmt
        self._reset(mark)
        while True:
            _last = self.expect("pass")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.del_stmt()
            del_stmt = _last
            if not _last:
                break
            return del_stmt
        self._reset(mark)
        while True:
            _last = self.yield_stmt()
            yield_stmt = _last
            if not _last:
                break
            return yield_stmt
        self._reset(mark)
        while True:
            _last = self.assert_stmt()
            assert_stmt = _last
            if not _last:
                break
            return assert_stmt
        self._reset(mark)
        while True:
            _last = self.expect("break")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("continue")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.global_stmt()
            global_stmt = _last
            if not _last:
                break
            return global_stmt
        self._reset(mark)
        while True:
            _last = self.nonlocal_stmt()
            nonlocal_stmt = _last
            if not _last:
                break
            return nonlocal_stmt
        self._reset(mark)
        return None

    @memoize
    def compound_stmt(self) -> Optional[Any]:
        # compound_stmt: function_def | if_stmt | class_def | with_stmt | for_stmt | try_stmt | while_stmt
        mark = self._mark()
        while True:
            _last = self.function_def()
            function_def = _last
            if not _last:
                break
            return function_def
        self._reset(mark)
        while True:
            _last = self.if_stmt()
            if_stmt = _last
            if not _last:
                break
            return if_stmt
        self._reset(mark)
        while True:
            _last = self.class_def()
            class_def = _last
            if not _last:
                break
            return class_def
        self._reset(mark)
        while True:
            _last = self.with_stmt()
            with_stmt = _last
            if not _last:
                break
            return with_stmt
        self._reset(mark)
        while True:
            _last = self.for_stmt()
            for_stmt = _last
            if not _last:
                break
            return for_stmt
        self._reset(mark)
        while True:
            _last = self.try_stmt()
            try_stmt = _last
            if not _last:
                break
            return try_stmt
        self._reset(mark)
        while True:
            _last = self.while_stmt()
            while_stmt = _last
            if not _last:
                break
            return while_stmt
        self._reset(mark)
        return None

    @memoize
    def assignment(self) -> Optional[Any]:
        # assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions)
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = (self._tmp_14(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [name, literal, expression, opt]
        self._reset(mark)
        while True:
            _last = self._tmp_15()
            _tmp_15 = _last
            if not _last:
                break
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = (self._tmp_16(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_tmp_15, literal, expression, opt]
        self._reset(mark)
        while True:
            _last = self._loop1_17()
            _loop1_17 = _last
            if not _last:
                break
            _last = self._tmp_18()
            _tmp_18 = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, "=")
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_loop1_17, _tmp_18, opt]
        self._reset(mark)
        cut = False
        while True:
            _last = self.single_target()
            single_target = _last
            if not _last:
                break
            _last = self.augassign()
            augassign = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self._tmp_19()
            _tmp_19 = _last
            if not _last:
                break
            return [single_target, augassign, _tmp_19]
        self._reset(mark)
        if cut:
            return None
        return None

    @memoize
    def augassign(self) -> Optional[Any]:
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self._mark()
        while True:
            _last = self.expect("+=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("-=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("*=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("@=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("/=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("%=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("&=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("|=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("^=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("<<=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect(">>=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("**=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("//=")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def global_stmt(self) -> Optional[Any]:
        # global_stmt: 'global' ','.NAME+
        mark = self._mark()
        while True:
            _last = self.expect("global")
            literal = _last
            if not _last:
                break
            _last = self._gather_20()
            _gather_20 = _last
            if not _last:
                break
            return [literal, _gather_20]
        self._reset(mark)
        return None

    @memoize
    def nonlocal_stmt(self) -> Optional[Any]:
        # nonlocal_stmt: 'nonlocal' ','.NAME+
        mark = self._mark()
        while True:
            _last = self.expect("nonlocal")
            literal = _last
            if not _last:
                break
            _last = self._gather_22()
            _gather_22 = _last
            if not _last:
                break
            return [literal, _gather_22]
        self._reset(mark)
        return None

    @memoize
    def yield_stmt(self) -> Optional[Any]:
        # yield_stmt: yield_expr
        mark = self._mark()
        while True:
            _last = self.yield_expr()
            yield_expr = _last
            if not _last:
                break
            return yield_expr
        self._reset(mark)
        return None

    @memoize
    def assert_stmt(self) -> Optional[Any]:
        # assert_stmt: 'assert' expression [',' expression]
        mark = self._mark()
        while True:
            _last = self.expect("assert")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = (self._tmp_24(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, expression, opt]
        self._reset(mark)
        return None

    @memoize
    def del_stmt(self) -> Optional[Any]:
        # del_stmt: 'del' del_targets &(';' | NEWLINE)
        mark = self._mark()
        while True:
            _last = self.expect("del")
            literal = _last
            if not _last:
                break
            _last = self.del_targets()
            del_targets = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self._tmp_25,
            )
            if not _last:
                break
            return [literal, del_targets]
        self._reset(mark)
        return None

    @memoize
    def import_stmt(self) -> Optional[Any]:
        # import_stmt: import_name | import_from
        mark = self._mark()
        while True:
            _last = self.import_name()
            import_name = _last
            if not _last:
                break
            return import_name
        self._reset(mark)
        while True:
            _last = self.import_from()
            import_from = _last
            if not _last:
                break
            return import_from
        self._reset(mark)
        return None

    @memoize
    def import_name(self) -> Optional[Any]:
        # import_name: 'import' dotted_as_names
        mark = self._mark()
        while True:
            _last = self.expect("import")
            literal = _last
            if not _last:
                break
            _last = self.dotted_as_names()
            dotted_as_names = _last
            if not _last:
                break
            return [literal, dotted_as_names]
        self._reset(mark)
        return None

    @memoize
    def import_from(self) -> Optional[Any]:
        # import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        mark = self._mark()
        while True:
            _last = self.expect("from")
            literal = _last
            if not _last:
                break
            _last = (self._loop0_26(),)
            _loop0_26 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.dotted_name()
            dotted_name = _last
            if not _last:
                break
            _last = self.expect("import")
            literal_1 = _last
            if not _last:
                break
            _last = self.import_from_targets()
            import_from_targets = _last
            if not _last:
                break
            return [literal, _loop0_26, dotted_name, literal_1, import_from_targets]
        self._reset(mark)
        while True:
            _last = self.expect("from")
            literal = _last
            if not _last:
                break
            _last = self._loop1_27()
            _loop1_27 = _last
            if not _last:
                break
            _last = self.expect("import")
            literal_1 = _last
            if not _last:
                break
            _last = self.import_from_targets()
            import_from_targets = _last
            if not _last:
                break
            return [literal, _loop1_27, literal_1, import_from_targets]
        self._reset(mark)
        return None

    @memoize
    def import_from_targets(self) -> Optional[Any]:
        # import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*'
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self.import_from_as_names()
            import_from_as_names = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, import_from_as_names, opt, literal_1]
        self._reset(mark)
        while True:
            _last = self.import_from_as_names()
            import_from_as_names = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, ",")
            if not _last:
                break
            return import_from_as_names
        self._reset(mark)
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def import_from_as_names(self) -> Optional[Any]:
        # import_from_as_names: ','.import_from_as_name+
        mark = self._mark()
        while True:
            _last = self._gather_28()
            _gather_28 = _last
            if not _last:
                break
            return _gather_28
        self._reset(mark)
        return None

    @memoize
    def import_from_as_name(self) -> Optional[Any]:
        # import_from_as_name: NAME ['as' NAME]
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = (self._tmp_30(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [name, opt]
        self._reset(mark)
        return None

    @memoize
    def dotted_as_names(self) -> Optional[Any]:
        # dotted_as_names: ','.dotted_as_name+
        mark = self._mark()
        while True:
            _last = self._gather_31()
            _gather_31 = _last
            if not _last:
                break
            return _gather_31
        self._reset(mark)
        return None

    @memoize
    def dotted_as_name(self) -> Optional[Any]:
        # dotted_as_name: dotted_name ['as' NAME]
        mark = self._mark()
        while True:
            _last = self.dotted_name()
            dotted_name = _last
            if not _last:
                break
            _last = (self._tmp_33(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [dotted_name, opt]
        self._reset(mark)
        return None

    @memoize_left_rec
    def dotted_name(self) -> Optional[Any]:
        # dotted_name: dotted_name '.' NAME | NAME
        mark = self._mark()
        while True:
            _last = self.dotted_name()
            dotted_name = _last
            if not _last:
                break
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            return [dotted_name, literal, name]
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        return None

    @memoize
    def if_stmt(self) -> Optional[Any]:
        # if_stmt: 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
        mark = self._mark()
        while True:
            _last = self.expect("if")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = self.elif_stmt()
            elif_stmt = _last
            if not _last:
                break
            return [literal, named_expression, literal_1, block, elif_stmt]
        self._reset(mark)
        while True:
            _last = self.expect("if")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = (self.else_block(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, named_expression, literal_1, block, opt]
        self._reset(mark)
        return None

    @memoize
    def elif_stmt(self) -> Optional[Any]:
        # elif_stmt: 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
        mark = self._mark()
        while True:
            _last = self.expect("elif")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = self.elif_stmt()
            elif_stmt = _last
            if not _last:
                break
            return [literal, named_expression, literal_1, block, elif_stmt]
        self._reset(mark)
        while True:
            _last = self.expect("elif")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = (self.else_block(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, named_expression, literal_1, block, opt]
        self._reset(mark)
        return None

    @memoize
    def else_block(self) -> Optional[Any]:
        # else_block: 'else' ':' block
        mark = self._mark()
        while True:
            _last = self.expect("else")
            literal = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, literal_1, block]
        self._reset(mark)
        return None

    @memoize
    def while_stmt(self) -> Optional[Any]:
        # while_stmt: 'while' named_expression ':' block else_block?
        mark = self._mark()
        while True:
            _last = self.expect("while")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = (self.else_block(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, named_expression, literal_1, block, opt]
        self._reset(mark)
        return None

    @memoize
    def for_stmt(self) -> Optional[Any]:
        # for_stmt: 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("for")
            literal = _last
            if not _last:
                break
            _last = self.star_targets()
            star_targets = _last
            if not _last:
                break
            _last = self.expect("in")
            literal_1 = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_2 = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = (self.else_block(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            return [
                literal,
                star_targets,
                literal_1,
                star_expressions,
                literal_2,
                opt,
                block,
                opt_1,
            ]
        self._reset(mark)
        if cut:
            return None
        cut = False
        while True:
            _last = self.expect("ASYNC")
            _async = _last
            if not _last:
                break
            _last = self.expect("for")
            literal = _last
            if not _last:
                break
            _last = self.star_targets()
            star_targets = _last
            if not _last:
                break
            _last = self.expect("in")
            literal_1 = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_2 = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = (self.else_block(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            return [
                _async,
                literal,
                star_targets,
                literal_1,
                star_expressions,
                literal_2,
                opt,
                block,
                opt_1,
            ]
        self._reset(mark)
        if cut:
            return None
        return None

    @memoize
    def with_stmt(self) -> Optional[Any]:
        # with_stmt: 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
        mark = self._mark()
        while True:
            _last = self.expect("with")
            literal = _last
            if not _last:
                break
            _last = self.expect("(")
            literal_1 = _last
            if not _last:
                break
            _last = self._gather_34()
            _gather_34 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_2 = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_3 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, literal_1, _gather_34, opt, literal_2, literal_3, block]
        self._reset(mark)
        while True:
            _last = self.expect("with")
            literal = _last
            if not _last:
                break
            _last = self._gather_36()
            _gather_36 = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, _gather_36, literal_1, opt, block]
        self._reset(mark)
        while True:
            _last = self.expect("ASYNC")
            _async = _last
            if not _last:
                break
            _last = self.expect("with")
            literal = _last
            if not _last:
                break
            _last = self.expect("(")
            literal_1 = _last
            if not _last:
                break
            _last = self._gather_38()
            _gather_38 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_2 = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_3 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [
                _async,
                literal,
                literal_1,
                _gather_38,
                opt,
                literal_2,
                literal_3,
                block,
            ]
        self._reset(mark)
        while True:
            _last = self.expect("ASYNC")
            _async = _last
            if not _last:
                break
            _last = self.expect("with")
            literal = _last
            if not _last:
                break
            _last = self._gather_40()
            _gather_40 = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [_async, literal, _gather_40, literal_1, opt, block]
        self._reset(mark)
        return None

    @memoize
    def with_item(self) -> Optional[Any]:
        # with_item: expression 'as' star_target &(',' | ')' | ':') | expression
        mark = self._mark()
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self.expect("as")
            literal = _last
            if not _last:
                break
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self._tmp_42,
            )
            if not _last:
                break
            return [expression, literal, star_target]
        self._reset(mark)
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return expression
        self._reset(mark)
        return None

    @memoize
    def try_stmt(self) -> Optional[Any]:
        # try_stmt: 'try' ':' block finally_block | 'try' ':' block except_block+ else_block? finally_block?
        mark = self._mark()
        while True:
            _last = self.expect("try")
            literal = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = self.finally_block()
            finally_block = _last
            if not _last:
                break
            return [literal, literal_1, block, finally_block]
        self._reset(mark)
        while True:
            _last = self.expect("try")
            literal = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            _last = self._loop1_43()
            _loop1_43 = _last
            if not _last:
                break
            _last = (self.else_block(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.finally_block(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            return [literal, literal_1, block, _loop1_43, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def except_block(self) -> Optional[Any]:
        # except_block: 'except' expression ['as' NAME] ':' block | 'except' ':' block
        mark = self._mark()
        while True:
            _last = self.expect("except")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = (self._tmp_44(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, expression, opt, literal_1, block]
        self._reset(mark)
        while True:
            _last = self.expect("except")
            literal = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, literal_1, block]
        self._reset(mark)
        return None

    @memoize
    def finally_block(self) -> Optional[Any]:
        # finally_block: 'finally' ':' block
        mark = self._mark()
        while True:
            _last = self.expect("finally")
            literal = _last
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, literal_1, block]
        self._reset(mark)
        return None

    @memoize
    def return_stmt(self) -> Optional[Any]:
        # return_stmt: 'return' star_expressions?
        mark = self._mark()
        while True:
            _last = self.expect("return")
            literal = _last
            if not _last:
                break
            _last = (self.star_expressions(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def raise_stmt(self) -> Optional[Any]:
        # raise_stmt: 'raise' expression ['from' expression] | 'raise'
        mark = self._mark()
        while True:
            _last = self.expect("raise")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = (self._tmp_45(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, expression, opt]
        self._reset(mark)
        while True:
            _last = self.expect("raise")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def function_def(self) -> Optional[Any]:
        # function_def: decorators function_def_raw | function_def_raw
        mark = self._mark()
        while True:
            _last = self.decorators()
            decorators = _last
            if not _last:
                break
            _last = self.function_def_raw()
            function_def_raw = _last
            if not _last:
                break
            return [decorators, function_def_raw]
        self._reset(mark)
        while True:
            _last = self.function_def_raw()
            function_def_raw = _last
            if not _last:
                break
            return function_def_raw
        self._reset(mark)
        return None

    @memoize
    def function_def_raw(self) -> Optional[Any]:
        # function_def_raw: 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block | ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
        mark = self._mark()
        while True:
            _last = self.expect("def")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("(")
            literal_1 = _last
            if not _last:
                break
            _last = (self.params(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_2 = _last
            if not _last:
                break
            _last = (self._tmp_46(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(":")
            literal_3 = _last
            if not _last:
                break
            _last = (self.func_type_comment(),)
            opt_2 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [
                literal,
                name,
                literal_1,
                opt,
                literal_2,
                opt_1,
                literal_3,
                opt_2,
                block,
            ]
        self._reset(mark)
        while True:
            _last = self.expect("ASYNC")
            _async = _last
            if not _last:
                break
            _last = self.expect("def")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("(")
            literal_1 = _last
            if not _last:
                break
            _last = (self.params(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_2 = _last
            if not _last:
                break
            _last = (self._tmp_47(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(":")
            literal_3 = _last
            if not _last:
                break
            _last = (self.func_type_comment(),)
            opt_2 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [
                _async,
                literal,
                name,
                literal_1,
                opt,
                literal_2,
                opt_1,
                literal_3,
                opt_2,
                block,
            ]
        self._reset(mark)
        return None

    @memoize
    def func_type_comment(self) -> Optional[Any]:
        # func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | TYPE_COMMENT
        mark = self._mark()
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            _last = self.type_comment()
            type_comment = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self._tmp_48,
            )
            if not _last:
                break
            return [_newline, type_comment]
        self._reset(mark)
        while True:
            _last = self.type_comment()
            type_comment = _last
            if not _last:
                break
            return type_comment
        self._reset(mark)
        return None

    @memoize
    def params(self) -> Optional[Any]:
        # params: parameters
        mark = self._mark()
        while True:
            _last = self.parameters()
            parameters = _last
            if not _last:
                break
            return parameters
        self._reset(mark)
        return None

    @memoize
    def parameters(self) -> Optional[Any]:
        # parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        mark = self._mark()
        while True:
            _last = self.slash_no_default()
            slash_no_default = _last
            if not _last:
                break
            _last = (self._loop0_49(),)
            _loop0_49 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self._loop0_50(),)
            _loop0_50 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [slash_no_default, _loop0_49, _loop0_50, opt]
        self._reset(mark)
        while True:
            _last = self.slash_with_default()
            slash_with_default = _last
            if not _last:
                break
            _last = (self._loop0_51(),)
            _loop0_51 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [slash_with_default, _loop0_51, opt]
        self._reset(mark)
        while True:
            _last = self._loop1_52()
            _loop1_52 = _last
            if not _last:
                break
            _last = (self._loop0_53(),)
            _loop0_53 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_loop1_52, _loop0_53, opt]
        self._reset(mark)
        while True:
            _last = self._loop1_54()
            _loop1_54 = _last
            if not _last:
                break
            _last = (self.star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_loop1_54, opt]
        self._reset(mark)
        while True:
            _last = self.star_etc()
            star_etc = _last
            if not _last:
                break
            return star_etc
        self._reset(mark)
        return None

    @memoize
    def slash_no_default(self) -> Optional[Any]:
        # slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        mark = self._mark()
        while True:
            _last = self._loop1_55()
            _loop1_55 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            return [_loop1_55, literal, literal_1]
        self._reset(mark)
        while True:
            _last = self._loop1_56()
            _loop1_56 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ")")
            if not _last:
                break
            return [_loop1_56, literal]
        self._reset(mark)
        return None

    @memoize
    def slash_with_default(self) -> Optional[Any]:
        # slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        mark = self._mark()
        while True:
            _last = (self._loop0_57(),)
            _loop0_57 = _last[0]
            _last = True
            if not _last:
                break
            _last = self._loop1_58()
            _loop1_58 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            return [_loop0_57, _loop1_58, literal, literal_1]
        self._reset(mark)
        while True:
            _last = (self._loop0_59(),)
            _loop0_59 = _last[0]
            _last = True
            if not _last:
                break
            _last = self._loop1_60()
            _loop1_60 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ")")
            if not _last:
                break
            return [_loop0_59, _loop1_60, literal]
        self._reset(mark)
        return None

    @memoize
    def star_etc(self) -> Optional[Any]:
        # star_etc: '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds
        mark = self._mark()
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            _last = (self._loop0_61(),)
            _loop0_61 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.kwds(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, param_no_default, _loop0_61, opt]
        self._reset(mark)
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            _last = self._loop1_62()
            _loop1_62 = _last
            if not _last:
                break
            _last = (self.kwds(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, literal_1, _loop1_62, opt]
        self._reset(mark)
        while True:
            _last = self.kwds()
            kwds = _last
            if not _last:
                break
            return kwds
        self._reset(mark)
        return None

    @memoize
    def kwds(self) -> Optional[Any]:
        # kwds: '**' param_no_default
        mark = self._mark()
        while True:
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            return [literal, param_no_default]
        self._reset(mark)
        return None

    @memoize
    def param_no_default(self) -> Optional[Any]:
        # param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
        mark = self._mark()
        while True:
            _last = self.param()
            param = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [param, literal, opt]
        self._reset(mark)
        while True:
            _last = self.param()
            param = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ")")
            if not _last:
                break
            return [param, opt]
        self._reset(mark)
        return None

    @memoize
    def param_with_default(self) -> Optional[Any]:
        # param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
        mark = self._mark()
        while True:
            _last = self.param()
            param = _last
            if not _last:
                break
            _last = self.default()
            default = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [param, default, literal, opt]
        self._reset(mark)
        while True:
            _last = self.param()
            param = _last
            if not _last:
                break
            _last = self.default()
            default = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ")")
            if not _last:
                break
            return [param, default, opt]
        self._reset(mark)
        return None

    @memoize
    def param_maybe_default(self) -> Optional[Any]:
        # param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
        mark = self._mark()
        while True:
            _last = self.param()
            param = _last
            if not _last:
                break
            _last = (self.default(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = (self.type_comment(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            return [param, opt, literal, opt_1]
        self._reset(mark)
        while True:
            _last = self.param()
            param = _last
            if not _last:
                break
            _last = (self.default(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.type_comment(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ")")
            if not _last:
                break
            return [param, opt, opt_1]
        self._reset(mark)
        return None

    @memoize
    def param(self) -> Optional[Any]:
        # param: NAME annotation?
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = (self.annotation(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [name, opt]
        self._reset(mark)
        return None

    @memoize
    def annotation(self) -> Optional[Any]:
        # annotation: ':' expression
        mark = self._mark()
        while True:
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def default(self) -> Optional[Any]:
        # default: '=' expression
        mark = self._mark()
        while True:
            _last = self.expect("=")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def decorators(self) -> Optional[Any]:
        # decorators: (('@' named_expression NEWLINE))+
        mark = self._mark()
        while True:
            _last = self._loop1_63()
            _loop1_63 = _last
            if not _last:
                break
            return _loop1_63
        self._reset(mark)
        return None

    @memoize
    def class_def(self) -> Optional[Any]:
        # class_def: decorators class_def_raw | class_def_raw
        mark = self._mark()
        while True:
            _last = self.decorators()
            decorators = _last
            if not _last:
                break
            _last = self.class_def_raw()
            class_def_raw = _last
            if not _last:
                break
            return [decorators, class_def_raw]
        self._reset(mark)
        while True:
            _last = self.class_def_raw()
            class_def_raw = _last
            if not _last:
                break
            return class_def_raw
        self._reset(mark)
        return None

    @memoize
    def class_def_raw(self) -> Optional[Any]:
        # class_def_raw: 'class' NAME ['(' arguments? ')'] ':' block
        mark = self._mark()
        while True:
            _last = self.expect("class")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = (self._tmp_64(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.block()
            block = _last
            if not _last:
                break
            return [literal, name, opt, literal_1, block]
        self._reset(mark)
        return None

    @memoize
    def block(self) -> Optional[Any]:
        # block: NEWLINE INDENT statements DEDENT | simple_stmt
        mark = self._mark()
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            _last = self.expect("INDENT")
            _indent = _last
            if not _last:
                break
            _last = self.statements()
            statements = _last
            if not _last:
                break
            _last = self.expect("DEDENT")
            _dedent = _last
            if not _last:
                break
            return [_newline, _indent, statements, _dedent]
        self._reset(mark)
        while True:
            _last = self.simple_stmt()
            simple_stmt = _last
            if not _last:
                break
            return simple_stmt
        self._reset(mark)
        return None

    @memoize
    def star_expressions(self) -> Optional[Any]:
        # star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
        mark = self._mark()
        while True:
            _last = self.star_expression()
            star_expression = _last
            if not _last:
                break
            _last = self._loop1_65()
            _loop1_65 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [star_expression, _loop1_65, opt]
        self._reset(mark)
        while True:
            _last = self.star_expression()
            star_expression = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return [star_expression, literal]
        self._reset(mark)
        while True:
            _last = self.star_expression()
            star_expression = _last
            if not _last:
                break
            return star_expression
        self._reset(mark)
        return None

    @memoize
    def star_expression(self) -> Optional[Any]:
        # star_expression: '*' bitwise_or | expression
        mark = self._mark()
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return expression
        self._reset(mark)
        return None

    @memoize
    def star_named_expressions(self) -> Optional[Any]:
        # star_named_expressions: ','.star_named_expression+ ','?
        mark = self._mark()
        while True:
            _last = self._gather_66()
            _gather_66 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_gather_66, opt]
        self._reset(mark)
        return None

    @memoize
    def star_named_expression(self) -> Optional[Any]:
        # star_named_expression: '*' bitwise_or | named_expression
        mark = self._mark()
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        while True:
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            return named_expression
        self._reset(mark)
        return None

    @memoize
    def named_expression(self) -> Optional[Any]:
        # named_expression: NAME ':=' ~ expression | expression !':='
        mark = self._mark()
        cut = False
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect(":=")
            literal = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [name, literal, expression]
        self._reset(mark)
        if cut:
            return None
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, ":=")
            if not _last:
                break
            return expression
        self._reset(mark)
        return None

    @memoize
    def annotated_rhs(self) -> Optional[Any]:
        # annotated_rhs: yield_expr | star_expressions
        mark = self._mark()
        while True:
            _last = self.yield_expr()
            yield_expr = _last
            if not _last:
                break
            return yield_expr
        self._reset(mark)
        while True:
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            return star_expressions
        self._reset(mark)
        return None

    @memoize
    def expressions(self) -> Optional[Any]:
        # expressions: expression ((',' expression))+ ','? | expression ',' | expression
        mark = self._mark()
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self._loop1_68()
            _loop1_68 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [expression, _loop1_68, opt]
        self._reset(mark)
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return [expression, literal]
        self._reset(mark)
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return expression
        self._reset(mark)
        return None

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        mark = self._mark()
        while True:
            _last = self.disjunction()
            disjunction = _last
            if not _last:
                break
            _last = self.expect("if")
            literal = _last
            if not _last:
                break
            _last = self.disjunction()
            disjunction_1 = _last
            if not _last:
                break
            _last = self.expect("else")
            literal_1 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [disjunction, literal, disjunction_1, literal_1, expression]
        self._reset(mark)
        while True:
            _last = self.disjunction()
            disjunction = _last
            if not _last:
                break
            return disjunction
        self._reset(mark)
        while True:
            _last = self.lambdef()
            lambdef = _last
            if not _last:
                break
            return lambdef
        self._reset(mark)
        return None

    @memoize
    def lambdef(self) -> Optional[Any]:
        # lambdef: 'lambda' lambda_params? ':' expression
        mark = self._mark()
        while True:
            _last = self.expect("lambda")
            literal = _last
            if not _last:
                break
            _last = (self.lambda_params(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(":")
            literal_1 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, opt, literal_1, expression]
        self._reset(mark)
        return None

    @memoize
    def lambda_params(self) -> Optional[Any]:
        # lambda_params: lambda_parameters
        mark = self._mark()
        while True:
            _last = self.lambda_parameters()
            lambda_parameters = _last
            if not _last:
                break
            return lambda_parameters
        self._reset(mark)
        return None

    @memoize
    def lambda_parameters(self) -> Optional[Any]:
        # lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
        mark = self._mark()
        while True:
            _last = self.lambda_slash_no_default()
            lambda_slash_no_default = _last
            if not _last:
                break
            _last = (self._loop0_69(),)
            _loop0_69 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self._loop0_70(),)
            _loop0_70 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.lambda_star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [lambda_slash_no_default, _loop0_69, _loop0_70, opt]
        self._reset(mark)
        while True:
            _last = self.lambda_slash_with_default()
            lambda_slash_with_default = _last
            if not _last:
                break
            _last = (self._loop0_71(),)
            _loop0_71 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.lambda_star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [lambda_slash_with_default, _loop0_71, opt]
        self._reset(mark)
        while True:
            _last = self._loop1_72()
            _loop1_72 = _last
            if not _last:
                break
            _last = (self._loop0_73(),)
            _loop0_73 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.lambda_star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_loop1_72, _loop0_73, opt]
        self._reset(mark)
        while True:
            _last = self._loop1_74()
            _loop1_74 = _last
            if not _last:
                break
            _last = (self.lambda_star_etc(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_loop1_74, opt]
        self._reset(mark)
        while True:
            _last = self.lambda_star_etc()
            lambda_star_etc = _last
            if not _last:
                break
            return lambda_star_etc
        self._reset(mark)
        return None

    @memoize
    def lambda_slash_no_default(self) -> Optional[Any]:
        # lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
        mark = self._mark()
        while True:
            _last = self._loop1_75()
            _loop1_75 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            return [_loop1_75, literal, literal_1]
        self._reset(mark)
        while True:
            _last = self._loop1_76()
            _loop1_76 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ":")
            if not _last:
                break
            return [_loop1_76, literal]
        self._reset(mark)
        return None

    @memoize
    def lambda_slash_with_default(self) -> Optional[Any]:
        # lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
        mark = self._mark()
        while True:
            _last = (self._loop0_77(),)
            _loop0_77 = _last[0]
            _last = True
            if not _last:
                break
            _last = self._loop1_78()
            _loop1_78 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            return [_loop0_77, _loop1_78, literal, literal_1]
        self._reset(mark)
        while True:
            _last = (self._loop0_79(),)
            _loop0_79 = _last[0]
            _last = True
            if not _last:
                break
            _last = self._loop1_80()
            _loop1_80 = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ":")
            if not _last:
                break
            return [_loop0_79, _loop1_80, literal]
        self._reset(mark)
        return None

    @memoize
    def lambda_star_etc(self) -> Optional[Any]:
        # lambda_star_etc: '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds
        mark = self._mark()
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            _last = (self._loop0_81(),)
            _loop0_81 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.lambda_kwds(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, lambda_param_no_default, _loop0_81, opt]
        self._reset(mark)
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.expect(",")
            literal_1 = _last
            if not _last:
                break
            _last = self._loop1_82()
            _loop1_82 = _last
            if not _last:
                break
            _last = (self.lambda_kwds(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, literal_1, _loop1_82, opt]
        self._reset(mark)
        while True:
            _last = self.lambda_kwds()
            lambda_kwds = _last
            if not _last:
                break
            return lambda_kwds
        self._reset(mark)
        return None

    @memoize
    def lambda_kwds(self) -> Optional[Any]:
        # lambda_kwds: '**' lambda_param_no_default
        mark = self._mark()
        while True:
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            return [literal, lambda_param_no_default]
        self._reset(mark)
        return None

    @memoize
    def lambda_param_no_default(self) -> Optional[Any]:
        # lambda_param_no_default: lambda_param ',' | lambda_param &':'
        mark = self._mark()
        while True:
            _last = self.lambda_param()
            lambda_param = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return [lambda_param, literal]
        self._reset(mark)
        while True:
            _last = self.lambda_param()
            lambda_param = _last
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ":")
            if not _last:
                break
            return lambda_param
        self._reset(mark)
        return None

    @memoize
    def lambda_param_with_default(self) -> Optional[Any]:
        # lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
        mark = self._mark()
        while True:
            _last = self.lambda_param()
            lambda_param = _last
            if not _last:
                break
            _last = self.default()
            default = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return [lambda_param, default, literal]
        self._reset(mark)
        while True:
            _last = self.lambda_param()
            lambda_param = _last
            if not _last:
                break
            _last = self.default()
            default = _last
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ":")
            if not _last:
                break
            return [lambda_param, default]
        self._reset(mark)
        return None

    @memoize
    def lambda_param_maybe_default(self) -> Optional[Any]:
        # lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
        mark = self._mark()
        while True:
            _last = self.lambda_param()
            lambda_param = _last
            if not _last:
                break
            _last = (self.default(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return [lambda_param, opt, literal]
        self._reset(mark)
        while True:
            _last = self.lambda_param()
            lambda_param = _last
            if not _last:
                break
            _last = (self.default(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ":")
            if not _last:
                break
            return [lambda_param, opt]
        self._reset(mark)
        return None

    @memoize
    def lambda_param(self) -> Optional[Any]:
        # lambda_param: NAME
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        return None

    @memoize
    def disjunction(self) -> Optional[Any]:
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        mark = self._mark()
        while True:
            _last = self.conjunction()
            conjunction = _last
            if not _last:
                break
            _last = self._loop1_83()
            _loop1_83 = _last
            if not _last:
                break
            return [conjunction, _loop1_83]
        self._reset(mark)
        while True:
            _last = self.conjunction()
            conjunction = _last
            if not _last:
                break
            return conjunction
        self._reset(mark)
        return None

    @memoize
    def conjunction(self) -> Optional[Any]:
        # conjunction: inversion (('and' inversion))+ | inversion
        mark = self._mark()
        while True:
            _last = self.inversion()
            inversion = _last
            if not _last:
                break
            _last = self._loop1_84()
            _loop1_84 = _last
            if not _last:
                break
            return [inversion, _loop1_84]
        self._reset(mark)
        while True:
            _last = self.inversion()
            inversion = _last
            if not _last:
                break
            return inversion
        self._reset(mark)
        return None

    @memoize
    def inversion(self) -> Optional[Any]:
        # inversion: 'not' inversion | comparison
        mark = self._mark()
        while True:
            _last = self.expect("not")
            literal = _last
            if not _last:
                break
            _last = self.inversion()
            inversion = _last
            if not _last:
                break
            return [literal, inversion]
        self._reset(mark)
        while True:
            _last = self.comparison()
            comparison = _last
            if not _last:
                break
            return comparison
        self._reset(mark)
        return None

    @memoize
    def comparison(self) -> Optional[Any]:
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        mark = self._mark()
        while True:
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            _last = self._loop1_85()
            _loop1_85 = _last
            if not _last:
                break
            return [bitwise_or, _loop1_85]
        self._reset(mark)
        while True:
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return bitwise_or
        self._reset(mark)
        return None

    @memoize
    def compare_op_bitwise_or_pair(self) -> Optional[Any]:
        # compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
        mark = self._mark()
        while True:
            _last = self.eq_bitwise_or()
            eq_bitwise_or = _last
            if not _last:
                break
            return eq_bitwise_or
        self._reset(mark)
        while True:
            _last = self.noteq_bitwise_or()
            noteq_bitwise_or = _last
            if not _last:
                break
            return noteq_bitwise_or
        self._reset(mark)
        while True:
            _last = self.lte_bitwise_or()
            lte_bitwise_or = _last
            if not _last:
                break
            return lte_bitwise_or
        self._reset(mark)
        while True:
            _last = self.lt_bitwise_or()
            lt_bitwise_or = _last
            if not _last:
                break
            return lt_bitwise_or
        self._reset(mark)
        while True:
            _last = self.gte_bitwise_or()
            gte_bitwise_or = _last
            if not _last:
                break
            return gte_bitwise_or
        self._reset(mark)
        while True:
            _last = self.gt_bitwise_or()
            gt_bitwise_or = _last
            if not _last:
                break
            return gt_bitwise_or
        self._reset(mark)
        while True:
            _last = self.notin_bitwise_or()
            notin_bitwise_or = _last
            if not _last:
                break
            return notin_bitwise_or
        self._reset(mark)
        while True:
            _last = self.in_bitwise_or()
            in_bitwise_or = _last
            if not _last:
                break
            return in_bitwise_or
        self._reset(mark)
        while True:
            _last = self.isnot_bitwise_or()
            isnot_bitwise_or = _last
            if not _last:
                break
            return isnot_bitwise_or
        self._reset(mark)
        while True:
            _last = self.is_bitwise_or()
            is_bitwise_or = _last
            if not _last:
                break
            return is_bitwise_or
        self._reset(mark)
        return None

    @memoize
    def eq_bitwise_or(self) -> Optional[Any]:
        # eq_bitwise_or: '==' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("==")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def noteq_bitwise_or(self) -> Optional[Any]:
        # noteq_bitwise_or: ('!=') bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("!=")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def lte_bitwise_or(self) -> Optional[Any]:
        # lte_bitwise_or: '<=' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("<=")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def lt_bitwise_or(self) -> Optional[Any]:
        # lt_bitwise_or: '<' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("<")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def gte_bitwise_or(self) -> Optional[Any]:
        # gte_bitwise_or: '>=' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect(">=")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def gt_bitwise_or(self) -> Optional[Any]:
        # gt_bitwise_or: '>' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect(">")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def notin_bitwise_or(self) -> Optional[Any]:
        # notin_bitwise_or: 'not' 'in' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("not")
            literal = _last
            if not _last:
                break
            _last = self.expect("in")
            literal_1 = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, literal_1, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def in_bitwise_or(self) -> Optional[Any]:
        # in_bitwise_or: 'in' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("in")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def isnot_bitwise_or(self) -> Optional[Any]:
        # isnot_bitwise_or: 'is' 'not' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("is")
            literal = _last
            if not _last:
                break
            _last = self.expect("not")
            literal_1 = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, literal_1, bitwise_or]
        self._reset(mark)
        return None

    @memoize
    def is_bitwise_or(self) -> Optional[Any]:
        # is_bitwise_or: 'is' bitwise_or
        mark = self._mark()
        while True:
            _last = self.expect("is")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_or(self) -> Optional[Any]:
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        mark = self._mark()
        while True:
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            _last = self.expect("|")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_xor()
            bitwise_xor = _last
            if not _last:
                break
            return [bitwise_or, literal, bitwise_xor]
        self._reset(mark)
        while True:
            _last = self.bitwise_xor()
            bitwise_xor = _last
            if not _last:
                break
            return bitwise_xor
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_xor(self) -> Optional[Any]:
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        mark = self._mark()
        while True:
            _last = self.bitwise_xor()
            bitwise_xor = _last
            if not _last:
                break
            _last = self.expect("^")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_and()
            bitwise_and = _last
            if not _last:
                break
            return [bitwise_xor, literal, bitwise_and]
        self._reset(mark)
        while True:
            _last = self.bitwise_and()
            bitwise_and = _last
            if not _last:
                break
            return bitwise_and
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_and(self) -> Optional[Any]:
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        mark = self._mark()
        while True:
            _last = self.bitwise_and()
            bitwise_and = _last
            if not _last:
                break
            _last = self.expect("&")
            literal = _last
            if not _last:
                break
            _last = self.shift_expr()
            shift_expr = _last
            if not _last:
                break
            return [bitwise_and, literal, shift_expr]
        self._reset(mark)
        while True:
            _last = self.shift_expr()
            shift_expr = _last
            if not _last:
                break
            return shift_expr
        self._reset(mark)
        return None

    @memoize_left_rec
    def shift_expr(self) -> Optional[Any]:
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self._mark()
        while True:
            _last = self.shift_expr()
            shift_expr = _last
            if not _last:
                break
            _last = self.expect("<<")
            literal = _last
            if not _last:
                break
            _last = self.sum()
            sum = _last
            if not _last:
                break
            return [shift_expr, literal, sum]
        self._reset(mark)
        while True:
            _last = self.shift_expr()
            shift_expr = _last
            if not _last:
                break
            _last = self.expect(">>")
            literal = _last
            if not _last:
                break
            _last = self.sum()
            sum = _last
            if not _last:
                break
            return [shift_expr, literal, sum]
        self._reset(mark)
        while True:
            _last = self.sum()
            sum = _last
            if not _last:
                break
            return sum
        self._reset(mark)
        return None

    @memoize
    def units(self) -> Optional[Any]:
        # units: NAME '/' units | NAME '*' units | NAME '**' NUMBER | NAME
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.units()
            units = _last
            if not _last:
                break
            return [name, literal, units]
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.units()
            units = _last
            if not _last:
                break
            return [name, literal, units]
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.number()
            number = _last
            if not _last:
                break
            return [name, literal, number]
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        return None

    @memoize_left_rec
    def sum(self) -> Optional[Any]:
        # sum: sum '+' term | sum '-' term | term
        mark = self._mark()
        while True:
            _last = self.sum()
            sum = _last
            if not _last:
                break
            _last = self.expect("+")
            literal = _last
            if not _last:
                break
            _last = self.term()
            term = _last
            if not _last:
                break
            return [sum, literal, term]
        self._reset(mark)
        while True:
            _last = self.sum()
            sum = _last
            if not _last:
                break
            _last = self.expect("-")
            literal = _last
            if not _last:
                break
            _last = self.term()
            term = _last
            if not _last:
                break
            return [sum, literal, term]
        self._reset(mark)
        while True:
            _last = self.term()
            term = _last
            if not _last:
                break
            return term
        self._reset(mark)
        return None

    @memoize_left_rec
    def term(self) -> Optional[Any]:
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        mark = self._mark()
        while True:
            _last = self.term()
            term = _last
            if not _last:
                break
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [term, literal, factor]
        self._reset(mark)
        while True:
            _last = self.term()
            term = _last
            if not _last:
                break
            _last = self.expect("/")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [term, literal, factor]
        self._reset(mark)
        while True:
            _last = self.term()
            term = _last
            if not _last:
                break
            _last = self.expect("//")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [term, literal, factor]
        self._reset(mark)
        while True:
            _last = self.term()
            term = _last
            if not _last:
                break
            _last = self.expect("%")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [term, literal, factor]
        self._reset(mark)
        while True:
            _last = self.term()
            term = _last
            if not _last:
                break
            _last = self.expect("@")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [term, literal, factor]
        self._reset(mark)
        while True:
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return factor
        self._reset(mark)
        return None

    @memoize
    def factor(self) -> Optional[Any]:
        # factor: '+' factor | '-' factor | '~' factor | power
        mark = self._mark()
        while True:
            _last = self.expect("+")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [literal, factor]
        self._reset(mark)
        while True:
            _last = self.expect("-")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [literal, factor]
        self._reset(mark)
        while True:
            _last = self.expect("~")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [literal, factor]
        self._reset(mark)
        while True:
            _last = self.power()
            power = _last
            if not _last:
                break
            return power
        self._reset(mark)
        return None

    @memoize
    def power(self) -> Optional[Any]:
        # power: await_primary '**' factor | await_primary
        mark = self._mark()
        while True:
            _last = self.await_primary()
            await_primary = _last
            if not _last:
                break
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.factor()
            factor = _last
            if not _last:
                break
            return [await_primary, literal, factor]
        self._reset(mark)
        while True:
            _last = self.await_primary()
            await_primary = _last
            if not _last:
                break
            return await_primary
        self._reset(mark)
        return None

    @memoize
    def await_primary(self) -> Optional[Any]:
        # await_primary: AWAIT primary | primary
        mark = self._mark()
        while True:
            _last = self.expect("AWAIT")
            _await = _last
            if not _last:
                break
            _last = self.primary()
            primary = _last
            if not _last:
                break
            return [_await, primary]
        self._reset(mark)
        while True:
            _last = self.primary()
            primary = _last
            if not _last:
                break
            return primary
        self._reset(mark)
        return None

    @memoize_left_rec
    def primary(self) -> Optional[Any]:
        # primary: primary '.' NAME | primary genexp | primary '(' arguments? ')' | primary '[' slices ']' | unit_atom | atom
        mark = self._mark()
        while True:
            _last = self.primary()
            primary = _last
            if not _last:
                break
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            return [primary, literal, name]
        self._reset(mark)
        while True:
            _last = self.primary()
            primary = _last
            if not _last:
                break
            _last = self.genexp()
            genexp = _last
            if not _last:
                break
            return [primary, genexp]
        self._reset(mark)
        while True:
            _last = self.primary()
            primary = _last
            if not _last:
                break
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self.arguments(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [primary, literal, opt, literal_1]
        self._reset(mark)
        while True:
            _last = self.primary()
            primary = _last
            if not _last:
                break
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = self.slices()
            slices = _last
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            return [primary, literal, slices, literal_1]
        self._reset(mark)
        while True:
            _last = self.unit_atom()
            unit_atom = _last
            if not _last:
                break
            return unit_atom
        self._reset(mark)
        while True:
            _last = self.atom()
            atom = _last
            if not _last:
                break
            return atom
        self._reset(mark)
        return None

    @memoize
    def slices(self) -> Optional[Any]:
        # slices: slice !',' | ','.slice+ ','?
        mark = self._mark()
        while True:
            _last = self.slice()
            slice = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, ",")
            if not _last:
                break
            return slice
        self._reset(mark)
        while True:
            _last = self._gather_86()
            _gather_86 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_gather_86, opt]
        self._reset(mark)
        return None

    @memoize
    def slice(self) -> Optional[Any]:
        # slice: expression? ':' expression? [':' expression?] | expression
        mark = self._mark()
        while True:
            _last = (self.expression(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            _last = (self.expression(),)
            opt_1 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self._tmp_88(),)
            opt_2 = _last[0]
            _last = True
            if not _last:
                break
            return [opt, literal, opt_1, opt_2]
        self._reset(mark)
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return expression
        self._reset(mark)
        return None

    @memoize
    def atom(self) -> Optional[Any]:
        # atom: NAME | 'True' | 'False' | 'None' | '__peg_parser__' | strings | NUMBER | (tuple | group | genexp) | (list | listcomp) | (dict | set | dictcomp | setcomp) | '...'
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        while True:
            _last = self.expect("True")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("False")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("None")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("__peg_parser__")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.strings()
            strings = _last
            if not _last:
                break
            return strings
        self._reset(mark)
        while True:
            _last = self.number()
            number = _last
            if not _last:
                break
            return number
        self._reset(mark)
        while True:
            _last = self._tmp_89()
            _tmp_89 = _last
            if not _last:
                break
            return _tmp_89
        self._reset(mark)
        while True:
            _last = self._tmp_90()
            _tmp_90 = _last
            if not _last:
                break
            return _tmp_90
        self._reset(mark)
        while True:
            _last = self._tmp_91()
            _tmp_91 = _last
            if not _last:
                break
            return _tmp_91
        self._reset(mark)
        while True:
            _last = self.expect("...")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def unit_atom(self) -> Optional[Any]:
        # unit_atom: atom units
        mark = self._mark()
        while True:
            _last = self.atom()
            a = _last
            if not _last:
                break
            _last = self.units()
            u = _last
            if not _last:
                break
            return ("unit_atom", a, u)
        self._reset(mark)
        return None

    @memoize
    def strings(self) -> Optional[Any]:
        # strings: STRING+
        mark = self._mark()
        while True:
            _last = self._loop1_92()
            _loop1_92 = _last
            if not _last:
                break
            return _loop1_92
        self._reset(mark)
        return None

    @memoize
    def list(self) -> Optional[Any]:
        # list: '[' star_named_expressions? ']'
        mark = self._mark()
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = (self.star_named_expressions(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def listcomp(self) -> Optional[Any]:
        # listcomp: '[' named_expression ~ for_if_clauses ']'
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.for_if_clauses()
            for_if_clauses = _last
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            return [literal, named_expression, for_if_clauses, literal_1]
        self._reset(mark)
        if cut:
            return None
        return None

    @memoize
    def tuple(self) -> Optional[Any]:
        # tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self._tmp_93(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def group(self) -> Optional[Any]:
        # group: '(' (yield_expr | named_expression) ')'
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self._tmp_94()
            _tmp_94 = _last
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, _tmp_94, literal_1]
        self._reset(mark)
        return None

    @memoize
    def genexp(self) -> Optional[Any]:
        # genexp: '(' named_expression ~ for_if_clauses ')'
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.for_if_clauses()
            for_if_clauses = _last
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, named_expression, for_if_clauses, literal_1]
        self._reset(mark)
        if cut:
            return None
        return None

    @memoize
    def set(self) -> Optional[Any]:
        # set: '{' star_named_expressions '}'
        mark = self._mark()
        while True:
            _last = self.expect("{")
            literal = _last
            if not _last:
                break
            _last = self.star_named_expressions()
            star_named_expressions = _last
            if not _last:
                break
            _last = self.expect("}")
            literal_1 = _last
            if not _last:
                break
            return [literal, star_named_expressions, literal_1]
        self._reset(mark)
        return None

    @memoize
    def setcomp(self) -> Optional[Any]:
        # setcomp: '{' named_expression ~ for_if_clauses '}'
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("{")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.for_if_clauses()
            for_if_clauses = _last
            if not _last:
                break
            _last = self.expect("}")
            literal_1 = _last
            if not _last:
                break
            return [literal, named_expression, for_if_clauses, literal_1]
        self._reset(mark)
        if cut:
            return None
        return None

    @memoize
    def dict(self) -> Optional[Any]:
        # dict: '{' double_starred_kvpairs? '}'
        mark = self._mark()
        while True:
            _last = self.expect("{")
            literal = _last
            if not _last:
                break
            _last = (self.double_starred_kvpairs(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("}")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def dictcomp(self) -> Optional[Any]:
        # dictcomp: '{' kvpair for_if_clauses '}'
        mark = self._mark()
        while True:
            _last = self.expect("{")
            literal = _last
            if not _last:
                break
            _last = self.kvpair()
            kvpair = _last
            if not _last:
                break
            _last = self.for_if_clauses()
            for_if_clauses = _last
            if not _last:
                break
            _last = self.expect("}")
            literal_1 = _last
            if not _last:
                break
            return [literal, kvpair, for_if_clauses, literal_1]
        self._reset(mark)
        return None

    @memoize
    def double_starred_kvpairs(self) -> Optional[Any]:
        # double_starred_kvpairs: ','.double_starred_kvpair+ ','?
        mark = self._mark()
        while True:
            _last = self._gather_95()
            _gather_95 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_gather_95, opt]
        self._reset(mark)
        return None

    @memoize
    def double_starred_kvpair(self) -> Optional[Any]:
        # double_starred_kvpair: '**' bitwise_or | kvpair
        mark = self._mark()
        while True:
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.bitwise_or()
            bitwise_or = _last
            if not _last:
                break
            return [literal, bitwise_or]
        self._reset(mark)
        while True:
            _last = self.kvpair()
            kvpair = _last
            if not _last:
                break
            return kvpair
        self._reset(mark)
        return None

    @memoize
    def kvpair(self) -> Optional[Any]:
        # kvpair: expression ':' expression
        mark = self._mark()
        while True:
            _last = self.expression()
            expression = _last
            if not _last:
                break
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression_1 = _last
            if not _last:
                break
            return [expression, literal, expression_1]
        self._reset(mark)
        return None

    @memoize
    def for_if_clauses(self) -> Optional[Any]:
        # for_if_clauses: for_if_clause+
        mark = self._mark()
        while True:
            _last = self._loop1_97()
            _loop1_97 = _last
            if not _last:
                break
            return _loop1_97
        self._reset(mark)
        return None

    @memoize
    def for_if_clause(self) -> Optional[Any]:
        # for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
        mark = self._mark()
        cut = False
        while True:
            _last = self.expect("ASYNC")
            _async = _last
            if not _last:
                break
            _last = self.expect("for")
            literal = _last
            if not _last:
                break
            _last = self.star_targets()
            star_targets = _last
            if not _last:
                break
            _last = self.expect("in")
            literal_1 = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.disjunction()
            disjunction = _last
            if not _last:
                break
            _last = (self._loop0_98(),)
            _loop0_98 = _last[0]
            _last = True
            if not _last:
                break
            return [_async, literal, star_targets, literal_1, disjunction, _loop0_98]
        self._reset(mark)
        if cut:
            return None
        cut = False
        while True:
            _last = self.expect("for")
            literal = _last
            if not _last:
                break
            _last = self.star_targets()
            star_targets = _last
            if not _last:
                break
            _last = self.expect("in")
            literal_1 = _last
            if not _last:
                break
            _last = True
            cut = _last
            if not _last:
                break
            _last = self.disjunction()
            disjunction = _last
            if not _last:
                break
            _last = (self._loop0_99(),)
            _loop0_99 = _last[0]
            _last = True
            if not _last:
                break
            return [literal, star_targets, literal_1, disjunction, _loop0_99]
        self._reset(mark)
        if cut:
            return None
        return None

    @memoize
    def yield_expr(self) -> Optional[Any]:
        # yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
        mark = self._mark()
        while True:
            _last = self.expect("yield")
            literal = _last
            if not _last:
                break
            _last = self.expect("from")
            literal_1 = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, literal_1, expression]
        self._reset(mark)
        while True:
            _last = self.expect("yield")
            literal = _last
            if not _last:
                break
            _last = (self.star_expressions(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def arguments(self) -> Optional[Any]:
        # arguments: args ','? &')'
        mark = self._mark()
        while True:
            _last = self.args()
            args = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.positive_lookahead(self.expect, ")")
            if not _last:
                break
            return [args, opt]
        self._reset(mark)
        return None

    @memoize
    def args(self) -> Optional[Any]:
        # args: ','.(starred_expression | named_expression !'=')+ [',' kwargs] | kwargs
        mark = self._mark()
        while True:
            _last = self._gather_100()
            _gather_100 = _last
            if not _last:
                break
            _last = (self._tmp_102(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_gather_100, opt]
        self._reset(mark)
        while True:
            _last = self.kwargs()
            kwargs = _last
            if not _last:
                break
            return kwargs
        self._reset(mark)
        return None

    @memoize
    def kwargs(self) -> Optional[Any]:
        # kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
        mark = self._mark()
        while True:
            _last = self._gather_103()
            _gather_103 = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self._gather_105()
            _gather_105 = _last
            if not _last:
                break
            return [_gather_103, literal, _gather_105]
        self._reset(mark)
        while True:
            _last = self._gather_107()
            _gather_107 = _last
            if not _last:
                break
            return _gather_107
        self._reset(mark)
        while True:
            _last = self._gather_109()
            _gather_109 = _last
            if not _last:
                break
            return _gather_109
        self._reset(mark)
        return None

    @memoize
    def starred_expression(self) -> Optional[Any]:
        # starred_expression: '*' expression
        mark = self._mark()
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def kwarg_or_starred(self) -> Optional[Any]:
        # kwarg_or_starred: NAME '=' expression | starred_expression
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("=")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [name, literal, expression]
        self._reset(mark)
        while True:
            _last = self.starred_expression()
            starred_expression = _last
            if not _last:
                break
            return starred_expression
        self._reset(mark)
        return None

    @memoize
    def kwarg_or_double_starred(self) -> Optional[Any]:
        # kwarg_or_double_starred: NAME '=' expression | '**' expression
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.expect("=")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [name, literal, expression]
        self._reset(mark)
        while True:
            _last = self.expect("**")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def star_targets(self) -> Optional[Any]:
        # star_targets: star_target !',' | star_target ((',' star_target))* ','?
        mark = self._mark()
        while True:
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, ",")
            if not _last:
                break
            return star_target
        self._reset(mark)
        while True:
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            _last = (self._loop0_111(),)
            _loop0_111 = _last[0]
            _last = True
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [star_target, _loop0_111, opt]
        self._reset(mark)
        return None

    @memoize
    def star_targets_list_seq(self) -> Optional[Any]:
        # star_targets_list_seq: ','.star_target+ ','?
        mark = self._mark()
        while True:
            _last = self._gather_112()
            _gather_112 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_gather_112, opt]
        self._reset(mark)
        return None

    @memoize
    def star_targets_tuple_seq(self) -> Optional[Any]:
        # star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
        mark = self._mark()
        while True:
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            _last = self._loop1_114()
            _loop1_114 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [star_target, _loop1_114, opt]
        self._reset(mark)
        while True:
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return [star_target, literal]
        self._reset(mark)
        return None

    @memoize
    def star_target(self) -> Optional[Any]:
        # star_target: '*' (!'*' star_target) | target_with_star_atom
        mark = self._mark()
        while True:
            _last = self.expect("*")
            literal = _last
            if not _last:
                break
            _last = self._tmp_115()
            _tmp_115 = _last
            if not _last:
                break
            return [literal, _tmp_115]
        self._reset(mark)
        while True:
            _last = self.target_with_star_atom()
            target_with_star_atom = _last
            if not _last:
                break
            return target_with_star_atom
        self._reset(mark)
        return None

    @memoize
    def target_with_star_atom(self) -> Optional[Any]:
        # target_with_star_atom: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
        mark = self._mark()
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.negative_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, name]
        self._reset(mark)
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = self.slices()
            slices = _last
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            _last = self.negative_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, slices, literal_1]
        self._reset(mark)
        while True:
            _last = self.star_atom()
            star_atom = _last
            if not _last:
                break
            return star_atom
        self._reset(mark)
        return None

    @memoize
    def star_atom(self) -> Optional[Any]:
        # star_atom: NAME | '(' target_with_star_atom ')' | '(' star_targets_tuple_seq? ')' | '[' star_targets_list_seq? ']'
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self.target_with_star_atom()
            target_with_star_atom = _last
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, target_with_star_atom, literal_1]
        self._reset(mark)
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self.star_targets_tuple_seq(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = (self.star_targets_list_seq(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def single_target(self) -> Optional[Any]:
        # single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
        mark = self._mark()
        while True:
            _last = self.single_subscript_attribute_target()
            single_subscript_attribute_target = _last
            if not _last:
                break
            return single_subscript_attribute_target
        self._reset(mark)
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self.single_target()
            single_target = _last
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, single_target, literal_1]
        self._reset(mark)
        return None

    @memoize
    def single_subscript_attribute_target(self) -> Optional[Any]:
        # single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
        mark = self._mark()
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.negative_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, name]
        self._reset(mark)
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = self.slices()
            slices = _last
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            _last = self.negative_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, slices, literal_1]
        self._reset(mark)
        return None

    @memoize
    def del_targets(self) -> Optional[Any]:
        # del_targets: ','.del_target+ ','?
        mark = self._mark()
        while True:
            _last = self._gather_116()
            _gather_116 = _last
            if not _last:
                break
            _last = (self.expect(","),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [_gather_116, opt]
        self._reset(mark)
        return None

    @memoize
    def del_target(self) -> Optional[Any]:
        # del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
        mark = self._mark()
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.negative_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, name]
        self._reset(mark)
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = self.slices()
            slices = _last
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            _last = self.negative_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, slices, literal_1]
        self._reset(mark)
        while True:
            _last = self.del_t_atom()
            del_t_atom = _last
            if not _last:
                break
            return del_t_atom
        self._reset(mark)
        return None

    @memoize
    def del_t_atom(self) -> Optional[Any]:
        # del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
        mark = self._mark()
        while True:
            _last = self.name()
            name = _last
            if not _last:
                break
            return name
        self._reset(mark)
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self.del_target()
            del_target = _last
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, del_target, literal_1]
        self._reset(mark)
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self.del_targets(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = (self.del_targets(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize_left_rec
    def t_primary(self) -> Optional[Any]:
        # t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments? ')' &t_lookahead | atom &t_lookahead
        mark = self._mark()
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, name]
        self._reset(mark)
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            _last = self.slices()
            slices = _last
            if not _last:
                break
            _last = self.expect("]")
            literal_1 = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, slices, literal_1]
        self._reset(mark)
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.genexp()
            genexp = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, genexp]
        self._reset(mark)
        while True:
            _last = self.t_primary()
            t_primary = _last
            if not _last:
                break
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self.arguments(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return [t_primary, literal, opt, literal_1]
        self._reset(mark)
        while True:
            _last = self.atom()
            atom = _last
            if not _last:
                break
            _last = self.positive_lookahead(
                self.t_lookahead,
            )
            if not _last:
                break
            return atom
        self._reset(mark)
        return None

    @memoize
    def t_lookahead(self) -> Optional[Any]:
        # t_lookahead: '(' | '[' | '.'
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("[")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: NEWLINE
        mark = self._mark()
        children = []
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_2(self) -> Optional[Any]:
        # _loop0_2: NEWLINE
        mark = self._mark()
        children = []
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: ',' expression
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_3(self) -> Optional[Any]:
        # _gather_3: expression _loop0_4
        mark = self._mark()
        while True:
            _last = self.expression()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_4()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_6(self) -> Optional[Any]:
        # _loop0_6: ',' expression
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_5(self) -> Optional[Any]:
        # _gather_5: expression _loop0_6
        mark = self._mark()
        while True:
            _last = self.expression()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_6()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_8(self) -> Optional[Any]:
        # _loop0_8: ',' expression
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_7(self) -> Optional[Any]:
        # _gather_7: expression _loop0_8
        mark = self._mark()
        while True:
            _last = self.expression()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_8()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: ',' expression
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_9(self) -> Optional[Any]:
        # _gather_9: expression _loop0_10
        mark = self._mark()
        while True:
            _last = self.expression()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_10()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop1_11(self) -> Optional[Any]:
        # _loop1_11: statement
        mark = self._mark()
        children = []
        while True:
            _last = self.statement()
            statement = _last
            if not _last:
                break
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_13(self) -> Optional[Any]:
        # _loop0_13: ';' small_stmt
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(";")
            literal = _last
            if not _last:
                break
            _last = self.small_stmt()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_12(self) -> Optional[Any]:
        # _gather_12: small_stmt _loop0_13
        mark = self._mark()
        while True:
            _last = self.small_stmt()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_13()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: '=' annotated_rhs
        mark = self._mark()
        while True:
            _last = self.expect("=")
            literal = _last
            if not _last:
                break
            _last = self.annotated_rhs()
            annotated_rhs = _last
            if not _last:
                break
            return [literal, annotated_rhs]
        self._reset(mark)
        return None

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: '(' single_target ')' | single_subscript_attribute_target
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = self.single_target()
            single_target = _last
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, single_target, literal_1]
        self._reset(mark)
        while True:
            _last = self.single_subscript_attribute_target()
            single_subscript_attribute_target = _last
            if not _last:
                break
            return single_subscript_attribute_target
        self._reset(mark)
        return None

    @memoize
    def _tmp_16(self) -> Optional[Any]:
        # _tmp_16: '=' annotated_rhs
        mark = self._mark()
        while True:
            _last = self.expect("=")
            literal = _last
            if not _last:
                break
            _last = self.annotated_rhs()
            annotated_rhs = _last
            if not _last:
                break
            return [literal, annotated_rhs]
        self._reset(mark)
        return None

    @memoize
    def _loop1_17(self) -> Optional[Any]:
        # _loop1_17: (star_targets '=')
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_118()
            _tmp_118 = _last
            if not _last:
                break
            children.append(_tmp_118)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_18(self) -> Optional[Any]:
        # _tmp_18: yield_expr | star_expressions
        mark = self._mark()
        while True:
            _last = self.yield_expr()
            yield_expr = _last
            if not _last:
                break
            return yield_expr
        self._reset(mark)
        while True:
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            return star_expressions
        self._reset(mark)
        return None

    @memoize
    def _tmp_19(self) -> Optional[Any]:
        # _tmp_19: yield_expr | star_expressions
        mark = self._mark()
        while True:
            _last = self.yield_expr()
            yield_expr = _last
            if not _last:
                break
            return yield_expr
        self._reset(mark)
        while True:
            _last = self.star_expressions()
            star_expressions = _last
            if not _last:
                break
            return star_expressions
        self._reset(mark)
        return None

    @memoize
    def _loop0_21(self) -> Optional[Any]:
        # _loop0_21: ',' NAME
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.name()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_20(self) -> Optional[Any]:
        # _gather_20: NAME _loop0_21
        mark = self._mark()
        while True:
            _last = self.name()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_21()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_23(self) -> Optional[Any]:
        # _loop0_23: ',' NAME
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.name()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_22(self) -> Optional[Any]:
        # _gather_22: NAME _loop0_23
        mark = self._mark()
        while True:
            _last = self.name()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_23()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_24(self) -> Optional[Any]:
        # _tmp_24: ',' expression
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_25(self) -> Optional[Any]:
        # _tmp_25: ';' | NEWLINE
        mark = self._mark()
        while True:
            _last = self.expect(";")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            return _newline
        self._reset(mark)
        return None

    @memoize
    def _loop0_26(self) -> Optional[Any]:
        # _loop0_26: ('.' | '...')
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_119()
            _tmp_119 = _last
            if not _last:
                break
            children.append(_tmp_119)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_27(self) -> Optional[Any]:
        # _loop1_27: ('.' | '...')
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_120()
            _tmp_120 = _last
            if not _last:
                break
            children.append(_tmp_120)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_29(self) -> Optional[Any]:
        # _loop0_29: ',' import_from_as_name
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.import_from_as_name()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_28(self) -> Optional[Any]:
        # _gather_28: import_from_as_name _loop0_29
        mark = self._mark()
        while True:
            _last = self.import_from_as_name()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_29()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_30(self) -> Optional[Any]:
        # _tmp_30: 'as' NAME
        mark = self._mark()
        while True:
            _last = self.expect("as")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _loop0_32(self) -> Optional[Any]:
        # _loop0_32: ',' dotted_as_name
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.dotted_as_name()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_31(self) -> Optional[Any]:
        # _gather_31: dotted_as_name _loop0_32
        mark = self._mark()
        while True:
            _last = self.dotted_as_name()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_32()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_33(self) -> Optional[Any]:
        # _tmp_33: 'as' NAME
        mark = self._mark()
        while True:
            _last = self.expect("as")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _loop0_35(self) -> Optional[Any]:
        # _loop0_35: ',' with_item
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.with_item()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_34(self) -> Optional[Any]:
        # _gather_34: with_item _loop0_35
        mark = self._mark()
        while True:
            _last = self.with_item()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_35()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_37(self) -> Optional[Any]:
        # _loop0_37: ',' with_item
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.with_item()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_36(self) -> Optional[Any]:
        # _gather_36: with_item _loop0_37
        mark = self._mark()
        while True:
            _last = self.with_item()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_37()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_39(self) -> Optional[Any]:
        # _loop0_39: ',' with_item
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.with_item()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_38(self) -> Optional[Any]:
        # _gather_38: with_item _loop0_39
        mark = self._mark()
        while True:
            _last = self.with_item()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_39()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_41(self) -> Optional[Any]:
        # _loop0_41: ',' with_item
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.with_item()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_40(self) -> Optional[Any]:
        # _gather_40: with_item _loop0_41
        mark = self._mark()
        while True:
            _last = self.with_item()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_41()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_42(self) -> Optional[Any]:
        # _tmp_42: ',' | ')' | ':'
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect(")")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def _loop1_43(self) -> Optional[Any]:
        # _loop1_43: except_block
        mark = self._mark()
        children = []
        while True:
            _last = self.except_block()
            except_block = _last
            if not _last:
                break
            children.append(except_block)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_44(self) -> Optional[Any]:
        # _tmp_44: 'as' NAME
        mark = self._mark()
        while True:
            _last = self.expect("as")
            literal = _last
            if not _last:
                break
            _last = self.name()
            name = _last
            if not _last:
                break
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_45(self) -> Optional[Any]:
        # _tmp_45: 'from' expression
        mark = self._mark()
        while True:
            _last = self.expect("from")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_46(self) -> Optional[Any]:
        # _tmp_46: '->' expression
        mark = self._mark()
        while True:
            _last = self.expect("->")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_47(self) -> Optional[Any]:
        # _tmp_47: '->' expression
        mark = self._mark()
        while True:
            _last = self.expect("->")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_48(self) -> Optional[Any]:
        # _tmp_48: NEWLINE INDENT
        mark = self._mark()
        while True:
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            _last = self.expect("INDENT")
            _indent = _last
            if not _last:
                break
            return [_newline, _indent]
        self._reset(mark)
        return None

    @memoize
    def _loop0_49(self) -> Optional[Any]:
        # _loop0_49: param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_50(self) -> Optional[Any]:
        # _loop0_50: param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_with_default()
            param_with_default = _last
            if not _last:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_51(self) -> Optional[Any]:
        # _loop0_51: param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_with_default()
            param_with_default = _last
            if not _last:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_52(self) -> Optional[Any]:
        # _loop1_52: param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_53(self) -> Optional[Any]:
        # _loop0_53: param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_with_default()
            param_with_default = _last
            if not _last:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_54(self) -> Optional[Any]:
        # _loop1_54: param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_with_default()
            param_with_default = _last
            if not _last:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_55(self) -> Optional[Any]:
        # _loop1_55: param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_56(self) -> Optional[Any]:
        # _loop1_56: param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_57(self) -> Optional[Any]:
        # _loop0_57: param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_58(self) -> Optional[Any]:
        # _loop1_58: param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_with_default()
            param_with_default = _last
            if not _last:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_59(self) -> Optional[Any]:
        # _loop0_59: param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_no_default()
            param_no_default = _last
            if not _last:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_60(self) -> Optional[Any]:
        # _loop1_60: param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_with_default()
            param_with_default = _last
            if not _last:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_61(self) -> Optional[Any]:
        # _loop0_61: param_maybe_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_maybe_default()
            param_maybe_default = _last
            if not _last:
                break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_62(self) -> Optional[Any]:
        # _loop1_62: param_maybe_default
        mark = self._mark()
        children = []
        while True:
            _last = self.param_maybe_default()
            param_maybe_default = _last
            if not _last:
                break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_63(self) -> Optional[Any]:
        # _loop1_63: ('@' named_expression NEWLINE)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_121()
            _tmp_121 = _last
            if not _last:
                break
            children.append(_tmp_121)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_64(self) -> Optional[Any]:
        # _tmp_64: '(' arguments? ')'
        mark = self._mark()
        while True:
            _last = self.expect("(")
            literal = _last
            if not _last:
                break
            _last = (self.arguments(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            _last = self.expect(")")
            literal_1 = _last
            if not _last:
                break
            return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _loop1_65(self) -> Optional[Any]:
        # _loop1_65: (',' star_expression)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_122()
            _tmp_122 = _last
            if not _last:
                break
            children.append(_tmp_122)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_67(self) -> Optional[Any]:
        # _loop0_67: ',' star_named_expression
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.star_named_expression()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_66(self) -> Optional[Any]:
        # _gather_66: star_named_expression _loop0_67
        mark = self._mark()
        while True:
            _last = self.star_named_expression()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_67()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop1_68(self) -> Optional[Any]:
        # _loop1_68: (',' expression)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_123()
            _tmp_123 = _last
            if not _last:
                break
            children.append(_tmp_123)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_69(self) -> Optional[Any]:
        # _loop0_69: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_70(self) -> Optional[Any]:
        # _loop0_70: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_with_default()
            lambda_param_with_default = _last
            if not _last:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_71(self) -> Optional[Any]:
        # _loop0_71: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_with_default()
            lambda_param_with_default = _last
            if not _last:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_72(self) -> Optional[Any]:
        # _loop1_72: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_73(self) -> Optional[Any]:
        # _loop0_73: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_with_default()
            lambda_param_with_default = _last
            if not _last:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_74(self) -> Optional[Any]:
        # _loop1_74: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_with_default()
            lambda_param_with_default = _last
            if not _last:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_75(self) -> Optional[Any]:
        # _loop1_75: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_76(self) -> Optional[Any]:
        # _loop1_76: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_77(self) -> Optional[Any]:
        # _loop0_77: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_78(self) -> Optional[Any]:
        # _loop1_78: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_with_default()
            lambda_param_with_default = _last
            if not _last:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_79(self) -> Optional[Any]:
        # _loop0_79: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_no_default()
            lambda_param_no_default = _last
            if not _last:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_80(self) -> Optional[Any]:
        # _loop1_80: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_with_default()
            lambda_param_with_default = _last
            if not _last:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_81(self) -> Optional[Any]:
        # _loop0_81: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_maybe_default()
            lambda_param_maybe_default = _last
            if not _last:
                break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_82(self) -> Optional[Any]:
        # _loop1_82: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while True:
            _last = self.lambda_param_maybe_default()
            lambda_param_maybe_default = _last
            if not _last:
                break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_83(self) -> Optional[Any]:
        # _loop1_83: ('or' conjunction)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_124()
            _tmp_124 = _last
            if not _last:
                break
            children.append(_tmp_124)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_84(self) -> Optional[Any]:
        # _loop1_84: ('and' inversion)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_125()
            _tmp_125 = _last
            if not _last:
                break
            children.append(_tmp_125)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_85(self) -> Optional[Any]:
        # _loop1_85: compare_op_bitwise_or_pair
        mark = self._mark()
        children = []
        while True:
            _last = self.compare_op_bitwise_or_pair()
            compare_op_bitwise_or_pair = _last
            if not _last:
                break
            children.append(compare_op_bitwise_or_pair)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_87(self) -> Optional[Any]:
        # _loop0_87: ',' slice
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.slice()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_86(self) -> Optional[Any]:
        # _gather_86: slice _loop0_87
        mark = self._mark()
        while True:
            _last = self.slice()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_87()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_88(self) -> Optional[Any]:
        # _tmp_88: ':' expression?
        mark = self._mark()
        while True:
            _last = self.expect(":")
            literal = _last
            if not _last:
                break
            _last = (self.expression(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_89(self) -> Optional[Any]:
        # _tmp_89: tuple | group | genexp
        mark = self._mark()
        while True:
            _last = self.tuple()
            tuple = _last
            if not _last:
                break
            return tuple
        self._reset(mark)
        while True:
            _last = self.group()
            group = _last
            if not _last:
                break
            return group
        self._reset(mark)
        while True:
            _last = self.genexp()
            genexp = _last
            if not _last:
                break
            return genexp
        self._reset(mark)
        return None

    @memoize
    def _tmp_90(self) -> Optional[Any]:
        # _tmp_90: list | listcomp
        mark = self._mark()
        while True:
            _last = self.list()
            list = _last
            if not _last:
                break
            return list
        self._reset(mark)
        while True:
            _last = self.listcomp()
            listcomp = _last
            if not _last:
                break
            return listcomp
        self._reset(mark)
        return None

    @memoize
    def _tmp_91(self) -> Optional[Any]:
        # _tmp_91: dict | set | dictcomp | setcomp
        mark = self._mark()
        while True:
            _last = self.dict()
            dict = _last
            if not _last:
                break
            return dict
        self._reset(mark)
        while True:
            _last = self.set()
            set = _last
            if not _last:
                break
            return set
        self._reset(mark)
        while True:
            _last = self.dictcomp()
            dictcomp = _last
            if not _last:
                break
            return dictcomp
        self._reset(mark)
        while True:
            _last = self.setcomp()
            setcomp = _last
            if not _last:
                break
            return setcomp
        self._reset(mark)
        return None

    @memoize
    def _loop1_92(self) -> Optional[Any]:
        # _loop1_92: STRING
        mark = self._mark()
        children = []
        while True:
            _last = self.string()
            string = _last
            if not _last:
                break
            children.append(string)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_93(self) -> Optional[Any]:
        # _tmp_93: star_named_expression ',' star_named_expressions?
        mark = self._mark()
        while True:
            _last = self.star_named_expression()
            star_named_expression = _last
            if not _last:
                break
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = (self.star_named_expressions(),)
            opt = _last[0]
            _last = True
            if not _last:
                break
            return [star_named_expression, literal, opt]
        self._reset(mark)
        return None

    @memoize
    def _tmp_94(self) -> Optional[Any]:
        # _tmp_94: yield_expr | named_expression
        mark = self._mark()
        while True:
            _last = self.yield_expr()
            yield_expr = _last
            if not _last:
                break
            return yield_expr
        self._reset(mark)
        while True:
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            return named_expression
        self._reset(mark)
        return None

    @memoize
    def _loop0_96(self) -> Optional[Any]:
        # _loop0_96: ',' double_starred_kvpair
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.double_starred_kvpair()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_95(self) -> Optional[Any]:
        # _gather_95: double_starred_kvpair _loop0_96
        mark = self._mark()
        while True:
            _last = self.double_starred_kvpair()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_96()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop1_97(self) -> Optional[Any]:
        # _loop1_97: for_if_clause
        mark = self._mark()
        children = []
        while True:
            _last = self.for_if_clause()
            for_if_clause = _last
            if not _last:
                break
            children.append(for_if_clause)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_98(self) -> Optional[Any]:
        # _loop0_98: ('if' disjunction)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_126()
            _tmp_126 = _last
            if not _last:
                break
            children.append(_tmp_126)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_99(self) -> Optional[Any]:
        # _loop0_99: ('if' disjunction)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_127()
            _tmp_127 = _last
            if not _last:
                break
            children.append(_tmp_127)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_101(self) -> Optional[Any]:
        # _loop0_101: ',' (starred_expression | named_expression !'=')
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self._tmp_128()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_100(self) -> Optional[Any]:
        # _gather_100: (starred_expression | named_expression !'=') _loop0_101
        mark = self._mark()
        while True:
            _last = self._tmp_128()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_101()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_102(self) -> Optional[Any]:
        # _tmp_102: ',' kwargs
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.kwargs()
            kwargs = _last
            if not _last:
                break
            return [literal, kwargs]
        self._reset(mark)
        return None

    @memoize
    def _loop0_104(self) -> Optional[Any]:
        # _loop0_104: ',' kwarg_or_starred
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.kwarg_or_starred()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_103(self) -> Optional[Any]:
        # _gather_103: kwarg_or_starred _loop0_104
        mark = self._mark()
        while True:
            _last = self.kwarg_or_starred()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_104()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_106(self) -> Optional[Any]:
        # _loop0_106: ',' kwarg_or_double_starred
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.kwarg_or_double_starred()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_105(self) -> Optional[Any]:
        # _gather_105: kwarg_or_double_starred _loop0_106
        mark = self._mark()
        while True:
            _last = self.kwarg_or_double_starred()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_106()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_108(self) -> Optional[Any]:
        # _loop0_108: ',' kwarg_or_starred
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.kwarg_or_starred()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_107(self) -> Optional[Any]:
        # _gather_107: kwarg_or_starred _loop0_108
        mark = self._mark()
        while True:
            _last = self.kwarg_or_starred()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_108()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_110(self) -> Optional[Any]:
        # _loop0_110: ',' kwarg_or_double_starred
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.kwarg_or_double_starred()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_109(self) -> Optional[Any]:
        # _gather_109: kwarg_or_double_starred _loop0_110
        mark = self._mark()
        while True:
            _last = self.kwarg_or_double_starred()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_110()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_111(self) -> Optional[Any]:
        # _loop0_111: (',' star_target)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_129()
            _tmp_129 = _last
            if not _last:
                break
            children.append(_tmp_129)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_113(self) -> Optional[Any]:
        # _loop0_113: ',' star_target
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.star_target()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_112(self) -> Optional[Any]:
        # _gather_112: star_target _loop0_113
        mark = self._mark()
        while True:
            _last = self.star_target()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_113()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop1_114(self) -> Optional[Any]:
        # _loop1_114: (',' star_target)
        mark = self._mark()
        children = []
        while True:
            _last = self._tmp_130()
            _tmp_130 = _last
            if not _last:
                break
            children.append(_tmp_130)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_115(self) -> Optional[Any]:
        # _tmp_115: !'*' star_target
        mark = self._mark()
        while True:
            _last = self.negative_lookahead(self.expect, "*")
            if not _last:
                break
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            return star_target
        self._reset(mark)
        return None

    @memoize
    def _loop0_117(self) -> Optional[Any]:
        # _loop0_117: ',' del_target
        mark = self._mark()
        children = []
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.del_target()
            elem = _last
            if not _last:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_116(self) -> Optional[Any]:
        # _gather_116: del_target _loop0_117
        mark = self._mark()
        while True:
            _last = self.del_target()
            elem = _last
            if _last is not None:
                break
            _last = self._loop0_117()
            seq = _last
            if _last is not None:
                break
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _tmp_118(self) -> Optional[Any]:
        # _tmp_118: star_targets '='
        mark = self._mark()
        while True:
            _last = self.star_targets()
            star_targets = _last
            if not _last:
                break
            _last = self.expect("=")
            literal = _last
            if not _last:
                break
            return [star_targets, literal]
        self._reset(mark)
        return None

    @memoize
    def _tmp_119(self) -> Optional[Any]:
        # _tmp_119: '.' | '...'
        mark = self._mark()
        while True:
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("...")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_120(self) -> Optional[Any]:
        # _tmp_120: '.' | '...'
        mark = self._mark()
        while True:
            _last = self.expect(".")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        while True:
            _last = self.expect("...")
            literal = _last
            if not _last:
                break
            return literal
        self._reset(mark)
        return None

    @memoize
    def _tmp_121(self) -> Optional[Any]:
        # _tmp_121: '@' named_expression NEWLINE
        mark = self._mark()
        while True:
            _last = self.expect("@")
            literal = _last
            if not _last:
                break
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.expect("NEWLINE")
            _newline = _last
            if not _last:
                break
            return [literal, named_expression, _newline]
        self._reset(mark)
        return None

    @memoize
    def _tmp_122(self) -> Optional[Any]:
        # _tmp_122: ',' star_expression
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.star_expression()
            star_expression = _last
            if not _last:
                break
            return [literal, star_expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_123(self) -> Optional[Any]:
        # _tmp_123: ',' expression
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.expression()
            expression = _last
            if not _last:
                break
            return [literal, expression]
        self._reset(mark)
        return None

    @memoize
    def _tmp_124(self) -> Optional[Any]:
        # _tmp_124: 'or' conjunction
        mark = self._mark()
        while True:
            _last = self.expect("or")
            literal = _last
            if not _last:
                break
            _last = self.conjunction()
            conjunction = _last
            if not _last:
                break
            return [literal, conjunction]
        self._reset(mark)
        return None

    @memoize
    def _tmp_125(self) -> Optional[Any]:
        # _tmp_125: 'and' inversion
        mark = self._mark()
        while True:
            _last = self.expect("and")
            literal = _last
            if not _last:
                break
            _last = self.inversion()
            inversion = _last
            if not _last:
                break
            return [literal, inversion]
        self._reset(mark)
        return None

    @memoize
    def _tmp_126(self) -> Optional[Any]:
        # _tmp_126: 'if' disjunction
        mark = self._mark()
        while True:
            _last = self.expect("if")
            literal = _last
            if not _last:
                break
            _last = self.disjunction()
            disjunction = _last
            if not _last:
                break
            return [literal, disjunction]
        self._reset(mark)
        return None

    @memoize
    def _tmp_127(self) -> Optional[Any]:
        # _tmp_127: 'if' disjunction
        mark = self._mark()
        while True:
            _last = self.expect("if")
            literal = _last
            if not _last:
                break
            _last = self.disjunction()
            disjunction = _last
            if not _last:
                break
            return [literal, disjunction]
        self._reset(mark)
        return None

    @memoize
    def _tmp_128(self) -> Optional[Any]:
        # _tmp_128: starred_expression | named_expression !'='
        mark = self._mark()
        while True:
            _last = self.starred_expression()
            starred_expression = _last
            if not _last:
                break
            return starred_expression
        self._reset(mark)
        while True:
            _last = self.named_expression()
            named_expression = _last
            if not _last:
                break
            _last = self.negative_lookahead(self.expect, "=")
            if not _last:
                break
            return named_expression
        self._reset(mark)
        return None

    @memoize
    def _tmp_129(self) -> Optional[Any]:
        # _tmp_129: ',' star_target
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            return [literal, star_target]
        self._reset(mark)
        return None

    @memoize
    def _tmp_130(self) -> Optional[Any]:
        # _tmp_130: ',' star_target
        mark = self._mark()
        while True:
            _last = self.expect(",")
            literal = _last
            if not _last:
                break
            _last = self.star_target()
            star_target = _last
            if not _last:
                break
            return [literal, star_target]
        self._reset(mark)
        return None

    KEYWORDS = (
        "False",
        "None",
        "True",
        "__peg_parser__",
        "and",
        "as",
        "assert",
        "break",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "in",
        "is",
        "lambda",
        "nonlocal",
        "not",
        "or",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield",
    )
    SOFT_KEYWORDS = ()


if __name__ == "__main__":
    from pegen.parser import simple_parser_main

    simple_parser_main(GeneratedParser)
